
# 第一章 基础概念
1. 补码：整数的补码是其加法逆元
 - 二进制，按位取反加一
 - 十六进制，转化为二进制或者用15减去每一位所得结果再加一
2. 有符号二进制整数，最高位1为负，0为正；最高位是1，则为补码；十六进制最高位大于等于8是正数否则是负数


# 第二章 X86架构相关概念
1. 三个操作模式：protected mode,virtual-8086 mode,real-address mode,system managerment mode
2. 寄存器组
 - 通用寄存器(8个)：EAX(extended accumulator),EBX(地址指针，保存被访问存储单元的偏移地址),ecx(默认为循环计数器),edx;上述四者都由16和8位寄存器组成，例如EAX：ax(16)+ah(8)+al(8)；ESP(extended stack pointer),ESI(extended source index),EDI(extended destination index),EBP(用于引用堆栈中的函数参数和局部变量，称为扩展帧指针extended frame pointer
 - 段指针(6个)，cs(code segment register),ds(data segment regiter),es(extra segment register),ss(stack segment register),fs(extra segment register,同es存储附加数据段段值),gs(同fs)
 - EFLAGS,处理器状态标志处理器
 - EIP指令指针寄存器，下一条要执行的指令地址，
 - MMX寄存器，
 - FPU，浮点单元含有八个80位的浮点数据寄存器分别命名为st(0),st(1)……  

 3. 内存相关。实地址模式，只能寻址1MB地址，范围00000H-FFFFFH,处理器一次只运行一个程序，可中断；保护模式，可同时运行多个模式，为每个程序分配4GB内存，例如linux;虚拟8086模式；虚拟8085模式中，计算机运行在保护模式下，通过创建一个带有1MB的地址空间的虚拟8086机器老模拟运行于实地址模式的80X86计算机
 4. X86-64处理器，向后兼容X86指令集，引入了新模式IA-32e，包含两个子模式：compatibility mode,64-bit mode；通用寄存器组扩充为16个64位处理器

 # 第三章汇编语言基础
 1. 分号添加注释，.data,.code,.stack添加数据段（定义变量）和代码段，运行时堆栈
 2. 整数常量：[{+|-}] digits [radix]，十六进制基数标志h（字母开头需前置0），八进制o或q，十进制d（可省略），二进制b
 3. 整型常量表达式：整数常量，算术表达式。
 4. 实数常量：[sign] integer.[integer][exponnent]，sign:{+,-},exponent:E[{+,-}]integer,至少需要一个数字和小数点；编码实数：十六进制实数
 5. 字符常量，用单引号或双引号包含的一个字符，汇编器在内存中保存该字符的二进制ASCII码数值
 6. 字符串常量，用单引号或双引号包含的一个字符序列（包含空格），引号允许嵌套，内存中保存形式为整数字节数字序列
 7. 保留字：不区分大小写，包含指令助记符，寄存器名称，伪指令，属性（提供变量和操作数的大小和使用信息），运算符，预定义符号
 8. 标识符：1-247个字符，不区分大小写，第一个字符为字母，下花香，@，？或$（避免使用_和$），不与保留字相同
 9. 伪指令：潜入代码中的命令，由汇编器识别执行。不在运行时执行，可定义变量，宏和子程序，为内存段分配名称，执行汇编器日常任务，不区分大小写
 10. 指令：[label:]mnemonic[operands][;comment]。标号(label)是一种标识符，是指令和数据的位置标记，分为数据标号和代码标号。程序代码区标号须有冒号结束。指令助记符(instruction mnemonic)。操作数(operands),数量在0到3个之间，可以是寄存器，内存操作数，整型常量表达式和输入输出端口
 11. 注释应包括程序目标说明，程序创建者和修改者的名单，程序创建和修改日期，程序实现技术说明。分号;指定单行注释；comment和一个用户指定符号定义块注释
 12. NOP空操作指令，占一个字节，常用作将代码对齐到有效的地址边界